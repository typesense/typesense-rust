/*
 * Typesense API
 *
 * An open source search engine for building delightful search experiences.
 *
 * The version of the OpenAPI document: 30.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use ::std::borrow::Cow;
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for passing parameters to the method [`delete_document`]
#[derive(Clone, Debug)]
pub struct DeleteDocumentParams<'p> {
    /// The name of the collection to search for the document under
    pub collection_name: Cow<'p, str>,
    /// The Document ID
    pub document_id: Cow<'p, str>,
}

/// struct for passing parameters to the method [`delete_documents`]
#[derive(Clone, Debug)]
pub struct DeleteDocumentsParams<'p> {
    /// The name of the collection to delete documents from
    pub collection_name: Cow<'p, str>,
    pub filter_by: Option<Cow<'p, str>>,
    pub batch_size: Option<i32>,
    pub ignore_not_found: Option<bool>,
    pub truncate: Option<bool>,
}

/// struct for passing parameters to the method [`export_documents`]
#[derive(Clone, Debug)]
pub struct ExportDocumentsParams<'p> {
    /// The name of the collection
    pub collection_name: Cow<'p, str>,
    pub filter_by: Option<Cow<'p, str>>,
    pub include_fields: Option<Cow<'p, str>>,
    pub exclude_fields: Option<Cow<'p, str>>,
}

/// struct for passing parameters to the method [`get_document`]
#[derive(Clone, Debug)]
pub struct GetDocumentParams<'p> {
    /// The name of the collection to search for the document under
    pub collection_name: Cow<'p, str>,
    /// The Document ID
    pub document_id: Cow<'p, str>,
}

/// struct for passing parameters to the method [`import_documents`]
#[derive(Clone, Debug)]
pub struct ImportDocumentsParams<'p> {
    /// The name of the collection
    pub collection_name: Cow<'p, str>,
    /// The json array of documents or the JSONL file to import
    pub body: Cow<'p, str>,
    pub batch_size: Option<i32>,
    pub return_id: Option<bool>,
    pub remote_embedding_batch_size: Option<i32>,
    pub return_doc: Option<bool>,
    pub action: Option<models::IndexAction>,
    pub dirty_values: Option<models::DirtyValues>,
}

/// struct for passing parameters to the method [`index_document`]
#[derive(Clone, Debug)]
pub struct IndexDocumentParams<'p> {
    /// The name of the collection to add the document to
    pub collection_name: Cow<'p, str>,
    /// The document object to be indexed
    pub body: serde_json::Value,
    /// Additional action to perform
    pub action: Option<Cow<'p, str>>,
    /// Dealing with Dirty Data
    pub dirty_values: Option<models::DirtyValues>,
}

/// struct for passing parameters to the method [`multi_search`]
#[derive(Clone, Debug)]
pub struct MultiSearchParams<'p> {
    pub q: Option<Cow<'p, str>>,
    pub query_by: Option<Cow<'p, str>>,
    pub query_by_weights: Option<Cow<'p, str>>,
    pub text_match_type: Option<Cow<'p, str>>,
    pub prefix: Option<Cow<'p, str>>,
    pub infix: Option<Cow<'p, str>>,
    pub max_extra_prefix: Option<i32>,
    pub max_extra_suffix: Option<i32>,
    pub filter_by: Option<Cow<'p, str>>,
    pub sort_by: Option<Cow<'p, str>>,
    pub facet_by: Option<Cow<'p, str>>,
    pub max_facet_values: Option<i32>,
    pub facet_query: Option<Cow<'p, str>>,
    pub num_typos: Option<Cow<'p, str>>,
    pub page: Option<i32>,
    pub per_page: Option<i32>,
    pub limit: Option<i32>,
    pub offset: Option<i32>,
    pub group_by: Option<Cow<'p, str>>,
    pub group_limit: Option<i32>,
    pub group_missing_values: Option<bool>,
    pub include_fields: Option<Cow<'p, str>>,
    pub exclude_fields: Option<Cow<'p, str>>,
    pub highlight_full_fields: Option<Cow<'p, str>>,
    pub highlight_affix_num_tokens: Option<i32>,
    pub highlight_start_tag: Option<Cow<'p, str>>,
    pub highlight_end_tag: Option<Cow<'p, str>>,
    pub snippet_threshold: Option<i32>,
    pub drop_tokens_threshold: Option<i32>,
    pub drop_tokens_mode: Option<models::DropTokensMode>,
    pub typo_tokens_threshold: Option<i32>,
    pub enable_typos_for_alpha_numerical_tokens: Option<bool>,
    pub filter_curated_hits: Option<bool>,
    pub enable_synonyms: Option<bool>,
    pub enable_analytics: Option<bool>,
    pub synonym_prefix: Option<bool>,
    pub synonym_num_typos: Option<i32>,
    pub pinned_hits: Option<Cow<'p, str>>,
    pub hidden_hits: Option<Cow<'p, str>>,
    pub override_tags: Option<Cow<'p, str>>,
    pub highlight_fields: Option<Cow<'p, str>>,
    pub pre_segmented_query: Option<bool>,
    pub preset: Option<Cow<'p, str>>,
    pub enable_overrides: Option<bool>,
    pub prioritize_exact_match: Option<bool>,
    pub prioritize_token_position: Option<bool>,
    pub prioritize_num_matching_fields: Option<bool>,
    pub enable_typos_for_numerical_tokens: Option<bool>,
    pub exhaustive_search: Option<bool>,
    pub search_cutoff_ms: Option<i32>,
    pub use_cache: Option<bool>,
    pub cache_ttl: Option<i32>,
    pub min_len_1typo: Option<i32>,
    pub min_len_2typo: Option<i32>,
    pub vector_query: Option<Cow<'p, str>>,
    pub remote_embedding_timeout_ms: Option<i32>,
    pub remote_embedding_num_tries: Option<i32>,
    pub facet_strategy: Option<Cow<'p, str>>,
    pub stopwords: Option<Cow<'p, str>>,
    pub facet_return_parent: Option<Cow<'p, str>>,
    pub voice_query: Option<Cow<'p, str>>,
    pub conversation: Option<bool>,
    pub conversation_model_id: Option<Cow<'p, str>>,
    pub conversation_id: Option<Cow<'p, str>>,
    pub multi_search_searches_parameter: Option<models::MultiSearchSearchesParameter<'p>>,
}

/// struct for passing parameters to the method [`search_collection`]
#[derive(Clone, Debug)]
pub struct SearchCollectionParams<'p> {
    /// The name of the collection to search for the document under
    pub collection_name: Cow<'p, str>,
    pub q: Option<Cow<'p, str>>,
    pub query_by: Option<Cow<'p, str>>,
    pub nl_query: Option<bool>,
    pub nl_model_id: Option<Cow<'p, str>>,
    pub query_by_weights: Option<Cow<'p, str>>,
    pub text_match_type: Option<Cow<'p, str>>,
    pub prefix: Option<Cow<'p, str>>,
    pub infix: Option<Cow<'p, str>>,
    pub max_extra_prefix: Option<i32>,
    pub max_extra_suffix: Option<i32>,
    pub filter_by: Option<Cow<'p, str>>,
    pub max_filter_by_candidates: Option<i32>,
    pub sort_by: Option<Cow<'p, str>>,
    pub facet_by: Option<Cow<'p, str>>,
    pub max_facet_values: Option<i32>,
    pub facet_query: Option<Cow<'p, str>>,
    pub num_typos: Option<Cow<'p, str>>,
    pub page: Option<i32>,
    pub per_page: Option<i32>,
    pub limit: Option<i32>,
    pub offset: Option<i32>,
    pub group_by: Option<Cow<'p, str>>,
    pub group_limit: Option<i32>,
    pub group_missing_values: Option<bool>,
    pub include_fields: Option<Cow<'p, str>>,
    pub exclude_fields: Option<Cow<'p, str>>,
    pub highlight_full_fields: Option<Cow<'p, str>>,
    pub highlight_affix_num_tokens: Option<i32>,
    pub highlight_start_tag: Option<Cow<'p, str>>,
    pub highlight_end_tag: Option<Cow<'p, str>>,
    pub enable_highlight_v1: Option<bool>,
    pub enable_analytics: Option<bool>,
    pub snippet_threshold: Option<i32>,
    pub synonym_sets: Option<Cow<'p, str>>,
    pub drop_tokens_threshold: Option<i32>,
    pub drop_tokens_mode: Option<models::DropTokensMode>,
    pub typo_tokens_threshold: Option<i32>,
    pub enable_typos_for_alpha_numerical_tokens: Option<bool>,
    pub filter_curated_hits: Option<bool>,
    pub enable_synonyms: Option<bool>,
    pub synonym_prefix: Option<bool>,
    pub synonym_num_typos: Option<i32>,
    pub pinned_hits: Option<Cow<'p, str>>,
    pub hidden_hits: Option<Cow<'p, str>>,
    pub override_tags: Option<Cow<'p, str>>,
    pub highlight_fields: Option<Cow<'p, str>>,
    pub split_join_tokens: Option<Cow<'p, str>>,
    pub pre_segmented_query: Option<bool>,
    pub preset: Option<Cow<'p, str>>,
    pub enable_overrides: Option<bool>,
    pub prioritize_exact_match: Option<bool>,
    pub max_candidates: Option<i32>,
    pub prioritize_token_position: Option<bool>,
    pub prioritize_num_matching_fields: Option<bool>,
    pub enable_typos_for_numerical_tokens: Option<bool>,
    pub exhaustive_search: Option<bool>,
    pub search_cutoff_ms: Option<i32>,
    pub use_cache: Option<bool>,
    pub cache_ttl: Option<i32>,
    pub min_len_1typo: Option<i32>,
    pub min_len_2typo: Option<i32>,
    pub vector_query: Option<Cow<'p, str>>,
    pub remote_embedding_timeout_ms: Option<i32>,
    pub remote_embedding_num_tries: Option<i32>,
    pub facet_strategy: Option<Cow<'p, str>>,
    pub stopwords: Option<Cow<'p, str>>,
    pub facet_return_parent: Option<Cow<'p, str>>,
    pub voice_query: Option<Cow<'p, str>>,
    pub conversation: Option<bool>,
    pub conversation_model_id: Option<Cow<'p, str>>,
    pub conversation_id: Option<Cow<'p, str>>,
}

/// struct for passing parameters to the method [`update_document`]
#[derive(Clone, Debug)]
pub struct UpdateDocumentParams<'p, B> {
    /// The name of the collection to search for the document under
    pub collection_name: Cow<'p, str>,
    /// The Document ID
    pub document_id: Cow<'p, str>,
    /// The document object with fields to be updated
    pub body: B,
    /// Dealing with Dirty Data
    pub dirty_values: Option<models::DirtyValues>,
}

/// struct for passing parameters to the method [`update_documents`]
#[derive(Clone, Debug)]
pub struct UpdateDocumentsParams<'p, B> {
    /// The name of the collection to update documents in
    pub collection_name: Cow<'p, str>,
    /// The document fields to be updated
    pub body: B,
    pub filter_by: Option<Cow<'p, str>>,
}

/// struct for typed errors of method [`delete_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentsError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportDocumentsError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`import_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportDocumentsError {
    Status400(models::ApiResponse),
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`index_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`multi_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MultiSearchError {
    Status400(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchCollectionError {
    Status400(models::ApiResponse),
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentError {
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentsError {
    Status400(models::ApiResponse),
    Status404(models::ApiResponse),
    UnknownValue(serde_json::Value),
}

/// Delete an individual document from a collection by using its ID.
pub async fn delete_document(
    configuration: &configuration::Configuration,
    params: &DeleteDocumentParams<'_>,
) -> Result<serde_json::Value, Error<DeleteDocumentError>> {
    let uri_str = format!(
        "{}/collections/{collectionName}/documents/{documentId}",
        configuration.base_path,
        collectionName = crate::apis::urlencode(&params.collection_name),
        documentId = crate::apis::urlencode(&params.document_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = &apikey.key;
        let value = match apikey.prefix {
            Some(ref prefix) => &format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a bunch of documents that match a specific filter condition. Use the `batch_size` parameter to control the number of documents that should deleted at a time. A larger value will speed up deletions, but will impact performance of other operations running on the server.
pub async fn delete_documents(
    configuration: &configuration::Configuration,
    params: &DeleteDocumentsParams<'_>,
) -> Result<models::DeleteDocuments200Response, Error<DeleteDocumentsError>> {
    let uri_str = format!(
        "{}/collections/{collectionName}/documents",
        configuration.base_path,
        collectionName = crate::apis::urlencode(&params.collection_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.filter_by {
        req_builder = req_builder.query(&[("filter_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.batch_size {
        req_builder = req_builder.query(&[("batch_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.ignore_not_found {
        req_builder = req_builder.query(&[("ignore_not_found", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.truncate {
        req_builder = req_builder.query(&[("truncate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = &apikey.key;
        let value = match apikey.prefix {
            Some(ref prefix) => &format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DeleteDocuments200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DeleteDocuments200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDocumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Export all documents in a collection in JSON lines format.
pub async fn export_documents(
    configuration: &configuration::Configuration,
    params: &ExportDocumentsParams<'_>,
) -> Result<String, Error<ExportDocumentsError>> {
    let uri_str = format!(
        "{}/collections/{collectionName}/documents/export",
        configuration.base_path,
        collectionName = crate::apis::urlencode(&params.collection_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.filter_by {
        req_builder = req_builder.query(&[("filter_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_fields {
        req_builder = req_builder.query(&[("include_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.exclude_fields {
        req_builder = req_builder.query(&[("exclude_fields", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = &apikey.key;
        let value = match apikey.prefix {
            Some(ref prefix) => &format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json | ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `String`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExportDocumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Fetch an individual document from a collection by using its ID.
pub async fn get_document(
    configuration: &configuration::Configuration,
    params: &GetDocumentParams<'_>,
) -> Result<serde_json::Value, Error<GetDocumentError>> {
    let uri_str = format!(
        "{}/collections/{collectionName}/documents/{documentId}",
        configuration.base_path,
        collectionName = crate::apis::urlencode(&params.collection_name),
        documentId = crate::apis::urlencode(&params.document_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = &apikey.key;
        let value = match apikey.prefix {
            Some(ref prefix) => &format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// The documents to be imported must be formatted in a newline delimited JSON structure. You can feed the output file from a Typesense export operation directly as import.
pub async fn import_documents(
    configuration: &configuration::Configuration,
    params: &ImportDocumentsParams<'_>,
) -> Result<String, Error<ImportDocumentsError>> {
    let uri_str = format!(
        "{}/collections/{collectionName}/documents/import",
        configuration.base_path,
        collectionName = crate::apis::urlencode(&params.collection_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.batch_size {
        req_builder = req_builder.query(&[("batch_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.return_id {
        req_builder = req_builder.query(&[("return_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.remote_embedding_batch_size {
        req_builder =
            req_builder.query(&[("remote_embedding_batch_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.return_doc {
        req_builder = req_builder.query(&[("return_doc", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.dirty_values {
        req_builder = req_builder.query(&[("dirty_values", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = &apikey.key;
        let value = match apikey.prefix {
            Some(ref prefix) => &format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };
    req_builder = req_builder
        .header(reqwest::header::CONTENT_TYPE, "text/plain")
        .body(params.body.clone().into_owned());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json | ContentType::Text => return Ok(content),
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `String`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ImportDocumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// A document to be indexed in a given collection must conform to the schema of the collection.
pub async fn index_document(
    configuration: &configuration::Configuration,
    params: &IndexDocumentParams<'_>,
) -> Result<serde_json::Value, Error<IndexDocumentError>> {
    let uri_str = format!(
        "{}/collections/{collectionName}/documents",
        configuration.base_path,
        collectionName = crate::apis::urlencode(&params.collection_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.dirty_values {
        req_builder = req_builder.query(&[("dirty_values", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = &apikey.key;
        let value = match apikey.prefix {
            Some(ref prefix) => &format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// This is especially useful to avoid round-trip network latencies incurred otherwise if each of these requests are sent in separate HTTP requests. You can also use this feature to do a federated search across multiple collections in a single HTTP request.
pub async fn multi_search(
    configuration: &configuration::Configuration,
    params: &MultiSearchParams<'_>,
) -> Result<serde_json::Value, Error<MultiSearchError>> {
    let uri_str = format!("{}/multi_search", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.query_by {
        req_builder = req_builder.query(&[("query_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.query_by_weights {
        req_builder = req_builder.query(&[("query_by_weights", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.text_match_type {
        req_builder = req_builder.query(&[("text_match_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.prefix {
        req_builder = req_builder.query(&[("prefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.infix {
        req_builder = req_builder.query(&[("infix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_extra_prefix {
        req_builder = req_builder.query(&[("max_extra_prefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_extra_suffix {
        req_builder = req_builder.query(&[("max_extra_suffix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.filter_by {
        req_builder = req_builder.query(&[("filter_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.facet_by {
        req_builder = req_builder.query(&[("facet_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_facet_values {
        req_builder = req_builder.query(&[("max_facet_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.facet_query {
        req_builder = req_builder.query(&[("facet_query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.num_typos {
        req_builder = req_builder.query(&[("num_typos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.group_by {
        req_builder = req_builder.query(&[("group_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.group_limit {
        req_builder = req_builder.query(&[("group_limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.group_missing_values {
        req_builder = req_builder.query(&[("group_missing_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_fields {
        req_builder = req_builder.query(&[("include_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.exclude_fields {
        req_builder = req_builder.query(&[("exclude_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.highlight_full_fields {
        req_builder = req_builder.query(&[("highlight_full_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.highlight_affix_num_tokens {
        req_builder =
            req_builder.query(&[("highlight_affix_num_tokens", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.highlight_start_tag {
        req_builder = req_builder.query(&[("highlight_start_tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.highlight_end_tag {
        req_builder = req_builder.query(&[("highlight_end_tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.snippet_threshold {
        req_builder = req_builder.query(&[("snippet_threshold", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.drop_tokens_threshold {
        req_builder = req_builder.query(&[("drop_tokens_threshold", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.drop_tokens_mode {
        req_builder = req_builder.query(&[("drop_tokens_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.typo_tokens_threshold {
        req_builder = req_builder.query(&[("typo_tokens_threshold", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enable_typos_for_alpha_numerical_tokens {
        req_builder = req_builder.query(&[(
            "enable_typos_for_alpha_numerical_tokens",
            &param_value.to_string(),
        )]);
    }
    if let Some(ref param_value) = params.filter_curated_hits {
        req_builder = req_builder.query(&[("filter_curated_hits", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enable_synonyms {
        req_builder = req_builder.query(&[("enable_synonyms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enable_analytics {
        req_builder = req_builder.query(&[("enable_analytics", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.synonym_prefix {
        req_builder = req_builder.query(&[("synonym_prefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.synonym_num_typos {
        req_builder = req_builder.query(&[("synonym_num_typos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.pinned_hits {
        req_builder = req_builder.query(&[("pinned_hits", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hidden_hits {
        req_builder = req_builder.query(&[("hidden_hits", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.override_tags {
        req_builder = req_builder.query(&[("override_tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.highlight_fields {
        req_builder = req_builder.query(&[("highlight_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.pre_segmented_query {
        req_builder = req_builder.query(&[("pre_segmented_query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.preset {
        req_builder = req_builder.query(&[("preset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enable_overrides {
        req_builder = req_builder.query(&[("enable_overrides", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.prioritize_exact_match {
        req_builder = req_builder.query(&[("prioritize_exact_match", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.prioritize_token_position {
        req_builder = req_builder.query(&[("prioritize_token_position", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.prioritize_num_matching_fields {
        req_builder =
            req_builder.query(&[("prioritize_num_matching_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enable_typos_for_numerical_tokens {
        req_builder = req_builder.query(&[(
            "enable_typos_for_numerical_tokens",
            &param_value.to_string(),
        )]);
    }
    if let Some(ref param_value) = params.exhaustive_search {
        req_builder = req_builder.query(&[("exhaustive_search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.search_cutoff_ms {
        req_builder = req_builder.query(&[("search_cutoff_ms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.use_cache {
        req_builder = req_builder.query(&[("use_cache", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cache_ttl {
        req_builder = req_builder.query(&[("cache_ttl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_len_1typo {
        req_builder = req_builder.query(&[("min_len_1typo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_len_2typo {
        req_builder = req_builder.query(&[("min_len_2typo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.vector_query {
        req_builder = req_builder.query(&[("vector_query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.remote_embedding_timeout_ms {
        req_builder =
            req_builder.query(&[("remote_embedding_timeout_ms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.remote_embedding_num_tries {
        req_builder =
            req_builder.query(&[("remote_embedding_num_tries", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.facet_strategy {
        req_builder = req_builder.query(&[("facet_strategy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.stopwords {
        req_builder = req_builder.query(&[("stopwords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.facet_return_parent {
        req_builder = req_builder.query(&[("facet_return_parent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.voice_query {
        req_builder = req_builder.query(&[("voice_query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.conversation {
        req_builder = req_builder.query(&[("conversation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.conversation_model_id {
        req_builder = req_builder.query(&[("conversation_model_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.conversation_id {
        req_builder = req_builder.query(&[("conversation_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = &apikey.key;
        let value = match apikey.prefix {
            Some(ref prefix) => &format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };
    req_builder = req_builder.json(&params.multi_search_searches_parameter);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MultiSearchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Search for documents in a collection that match the search criteria.
pub async fn search_collection<D: for<'de> serde::Deserialize<'de> + Serialize>(
    configuration: &configuration::Configuration,
    params: &SearchCollectionParams<'_>,
) -> Result<models::SearchResult<D>, Error<SearchCollectionError>> {
    let uri_str = format!(
        "{}/collections/{collectionName}/documents/search",
        configuration.base_path,
        collectionName = crate::apis::urlencode(&params.collection_name)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.q {
        req_builder = req_builder.query(&[("q", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.query_by {
        req_builder = req_builder.query(&[("query_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nl_query {
        req_builder = req_builder.query(&[("nl_query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.nl_model_id {
        req_builder = req_builder.query(&[("nl_model_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.query_by_weights {
        req_builder = req_builder.query(&[("query_by_weights", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.text_match_type {
        req_builder = req_builder.query(&[("text_match_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.prefix {
        req_builder = req_builder.query(&[("prefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.infix {
        req_builder = req_builder.query(&[("infix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_extra_prefix {
        req_builder = req_builder.query(&[("max_extra_prefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_extra_suffix {
        req_builder = req_builder.query(&[("max_extra_suffix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.filter_by {
        req_builder = req_builder.query(&[("filter_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_filter_by_candidates {
        req_builder = req_builder.query(&[("max_filter_by_candidates", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sort_by {
        req_builder = req_builder.query(&[("sort_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.facet_by {
        req_builder = req_builder.query(&[("facet_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_facet_values {
        req_builder = req_builder.query(&[("max_facet_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.facet_query {
        req_builder = req_builder.query(&[("facet_query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.num_typos {
        req_builder = req_builder.query(&[("num_typos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.group_by {
        req_builder = req_builder.query(&[("group_by", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.group_limit {
        req_builder = req_builder.query(&[("group_limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.group_missing_values {
        req_builder = req_builder.query(&[("group_missing_values", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_fields {
        req_builder = req_builder.query(&[("include_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.exclude_fields {
        req_builder = req_builder.query(&[("exclude_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.highlight_full_fields {
        req_builder = req_builder.query(&[("highlight_full_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.highlight_affix_num_tokens {
        req_builder =
            req_builder.query(&[("highlight_affix_num_tokens", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.highlight_start_tag {
        req_builder = req_builder.query(&[("highlight_start_tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.highlight_end_tag {
        req_builder = req_builder.query(&[("highlight_end_tag", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enable_highlight_v1 {
        req_builder = req_builder.query(&[("enable_highlight_v1", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enable_analytics {
        req_builder = req_builder.query(&[("enable_analytics", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.snippet_threshold {
        req_builder = req_builder.query(&[("snippet_threshold", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.synonym_sets {
        req_builder = req_builder.query(&[("synonym_sets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.drop_tokens_threshold {
        req_builder = req_builder.query(&[("drop_tokens_threshold", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.drop_tokens_mode {
        req_builder = req_builder.query(&[("drop_tokens_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.typo_tokens_threshold {
        req_builder = req_builder.query(&[("typo_tokens_threshold", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enable_typos_for_alpha_numerical_tokens {
        req_builder = req_builder.query(&[(
            "enable_typos_for_alpha_numerical_tokens",
            &param_value.to_string(),
        )]);
    }
    if let Some(ref param_value) = params.filter_curated_hits {
        req_builder = req_builder.query(&[("filter_curated_hits", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enable_synonyms {
        req_builder = req_builder.query(&[("enable_synonyms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.synonym_prefix {
        req_builder = req_builder.query(&[("synonym_prefix", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.synonym_num_typos {
        req_builder = req_builder.query(&[("synonym_num_typos", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.pinned_hits {
        req_builder = req_builder.query(&[("pinned_hits", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hidden_hits {
        req_builder = req_builder.query(&[("hidden_hits", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.override_tags {
        req_builder = req_builder.query(&[("override_tags", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.highlight_fields {
        req_builder = req_builder.query(&[("highlight_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.split_join_tokens {
        req_builder = req_builder.query(&[("split_join_tokens", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.pre_segmented_query {
        req_builder = req_builder.query(&[("pre_segmented_query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.preset {
        req_builder = req_builder.query(&[("preset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enable_overrides {
        req_builder = req_builder.query(&[("enable_overrides", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.prioritize_exact_match {
        req_builder = req_builder.query(&[("prioritize_exact_match", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_candidates {
        req_builder = req_builder.query(&[("max_candidates", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.prioritize_token_position {
        req_builder = req_builder.query(&[("prioritize_token_position", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.prioritize_num_matching_fields {
        req_builder =
            req_builder.query(&[("prioritize_num_matching_fields", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.enable_typos_for_numerical_tokens {
        req_builder = req_builder.query(&[(
            "enable_typos_for_numerical_tokens",
            &param_value.to_string(),
        )]);
    }
    if let Some(ref param_value) = params.exhaustive_search {
        req_builder = req_builder.query(&[("exhaustive_search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.search_cutoff_ms {
        req_builder = req_builder.query(&[("search_cutoff_ms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.use_cache {
        req_builder = req_builder.query(&[("use_cache", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.cache_ttl {
        req_builder = req_builder.query(&[("cache_ttl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_len_1typo {
        req_builder = req_builder.query(&[("min_len_1typo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_len_2typo {
        req_builder = req_builder.query(&[("min_len_2typo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.vector_query {
        req_builder = req_builder.query(&[("vector_query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.remote_embedding_timeout_ms {
        req_builder =
            req_builder.query(&[("remote_embedding_timeout_ms", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.remote_embedding_num_tries {
        req_builder =
            req_builder.query(&[("remote_embedding_num_tries", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.facet_strategy {
        req_builder = req_builder.query(&[("facet_strategy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.stopwords {
        req_builder = req_builder.query(&[("stopwords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.facet_return_parent {
        req_builder = req_builder.query(&[("facet_return_parent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.voice_query {
        req_builder = req_builder.query(&[("voice_query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.conversation {
        req_builder = req_builder.query(&[("conversation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.conversation_model_id {
        req_builder = req_builder.query(&[("conversation_model_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.conversation_id {
        req_builder = req_builder.query(&[("conversation_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = &apikey.key;
        let value = match apikey.prefix {
            Some(ref prefix) => &format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SearchResult<D>`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SearchResult<D>`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchCollectionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update an individual document from a collection by using its ID. The update can be partial.
pub async fn update_document<B: Serialize>(
    configuration: &configuration::Configuration,
    params: &UpdateDocumentParams<'_, B>,
) -> Result<serde_json::Value, Error<UpdateDocumentError>> {
    let uri_str = format!(
        "{}/collections/{collectionName}/documents/{documentId}",
        configuration.base_path,
        collectionName = crate::apis::urlencode(&params.collection_name),
        documentId = crate::apis::urlencode(&params.document_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = params.dirty_values {
        req_builder = req_builder.query(&[("dirty_values", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = &apikey.key;
        let value = match apikey.prefix {
            Some(ref prefix) => &format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateDocumentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// The filter_by query parameter is used to filter to specify a condition against which the documents are matched. The request body contains the fields that should be updated for any documents that match the filter condition. This endpoint is only available if the Typesense server is version `0.25.0.rc12` or later.
pub async fn update_documents<B: Serialize>(
    configuration: &configuration::Configuration,
    params: &UpdateDocumentsParams<'_, B>,
) -> Result<models::UpdateDocuments200Response, Error<UpdateDocumentsError>> {
    let uri_str = format!(
        "{}/collections/{collectionName}/documents",
        configuration.base_path,
        collectionName = crate::apis::urlencode(&params.collection_name)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref param_value) = params.filter_by {
        req_builder = req_builder.query(&[("filter_by", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = &apikey.key;
        let value = match apikey.prefix {
            Some(ref prefix) => &format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("X-TYPESENSE-API-KEY", value);
    };
    req_builder = req_builder.json(&params.body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UpdateDocuments200Response`",
                )));
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UpdateDocuments200Response`"
                ))));
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateDocumentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
